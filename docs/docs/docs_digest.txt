# Project Structure
```
docs(00-Introduction.md 01-Getting-Started.md 02-Core-Architecture.md 03-Fundamental-Concepts.md 04-Data-Logic-Workflows.md 05-Rendering-and-Views.md 06-Networking.md 07-Advanced-Topics.md Cookbook-Best-Practices.md)
```

# Codebase Analysis for: docs
## Total Tokens (included files): 9.859
---

### File: 00-Introduction.md
```md
# 00: Introduction to ME.BECS ```mermaid --- config: theme: dark --- graph LR subgraph ME.BECS Core Pillars A[Performance] B[Determinism] C[Networking] end subgraph Performance Features direction LR A1[Burst Compiler] A2[Zero GC] A3[Custom Allocators] A4[Unsafe Code] end subgraph Determinism Features direction LR B1[Custom Math Library] B2[Fixed-Point Types] B3[Deterministic Logic] end subgraph Networking Features direction LR C1[Input Prediction] C2[Server Rollback] C3[Replays] end A --> A1 & A2 & A3 & A4 B --> B1 & B2 & B3 C --> C1 & C2 & C3 style A fill:#2E8B57,stroke:#fff style B fill:#4682B4,stroke:#fff style C fill:#B22222,stroke:#fff ``` ## What is ME.BECS? ME.BECS (Bursted Entity Component System) is a high-performance, third-party ECS framework for Unity, designed from the ground up with a primary focus on **performance**, **determinism**, and **first-class networking**. It serves as a powerful alternative to Unity's native DOTS/ECS, offering a robust and opinionated architecture for building complex, scalable, and network-ready applications. At its core, ME.BECS leverages the full power of Unity's Burst compiler, extensive use of `unsafe` C#, and custom memory allocators to achieve near-zero garbage collection (GC) and exceptionally fast run-time execution. ## Core Benefits & When to Choose ME.BECS You should consider using ME.BECS for projects where the following are critical requirements: #### 1. **Extreme Performance is Non-Negotiable** The framework is built to squeeze the maximum performance out of the hardware. * **Burst & Unsafe:** Nearly 99% of the codebase is `unsafe` and designed to be compiled with Burst, eliminating overhead. * **Zero GC:** Custom memory management avoids GC pauses, which is critical for smooth gameplay in complex simulations. * **Direct Memory Access:** The API is designed to work in parallel jobs without the need to copy data to intermediate `NativeArray` containers. #### 2. **Deterministic Simulation is Required** ME.BECS guarantees that given the same sequence of inputs, the simulation will produce the exact same output every time. This is a foundational requirement for: * **Lockstep Networking:** Ensuring all clients in a multiplayer session remain perfectly synchronized. * **Replays:** Recording a stream of inputs is all that's needed to perfectly reconstruct a game session for debugging, analysis, or spectator modes. * **Fairness:** Eliminating simulation drift between clients in competitive games. #### 3. **Complex Networking with Prediction & Rollback is a Core Feature** Unlike many frameworks where networking is an afterthought, ME.BECS is built around a sophisticated networking model. * **First-Class Networking:** The framework includes built-in support for client-side prediction and server-side rollback. * **Smooth Experience:** Players experience a responsive, lag-free game, as their inputs are predicted locally. The framework automatically corrects any mispredictions based on the authoritative state from the server. * **Scalability:** The architecture is designed to handle the demands of real-time multiplayer games. In summary, choose **ME.BECS** when you are building a demanding, simulation-heavy game (like an RTS, MOBA, or physics-based sandbox) where performance and network synchronization are paramount. It provides a complete, end-to-end solution for these challenges, complete with a rich set of editor tools to streamline development.
```

### File: 01-Getting-Started.md
```md
# 01: Getting Started with ME.BECS This guide will walk you through the initial setup of a ME.BECS project in Unity. ```mermaid --- config: theme: dark --- graph TD A[Start] --> B[Install Dependencies]; B --> C[Install ME.BECS Package]; C --> D[Configure Project Settings]; D --> E{Project Type?}; E -- Singleplayer --> F[Create Singleplayer Project]; E -- Multiplayer --> G[Create Multiplayer Project]; F --> H[Write 'Hello World' System]; G --> H; H --> I[Connect System in Graph]; I --> J[Run Scene]; style A fill:#228B22 style J fill:#228B22 ``` ## 1. Prerequisites & Dependencies ME.BECS requires **Unity 2023.1 or later**. Before installing the framework, ensure your Unity project's `manifest.json` includes the following packages. You can add them via the Unity Package Manager. ```json "dependencies": { "com.unity.collections": "2.5.2", "com.unity.burst": "1.8.19", "com.unity.mathematics": "1.3.2", "com.unity.profiling.core": "1.0.2", "com.unity.ui": "2.0.0" } ``` ## 2. Installation Install the framework using the Unity Package Manager: 1. Go to **Window > Package Manager**. 2. Click the **'+'** icon and select **"Add package from git URL..."**. 3. Enter the following URL: `https://github.com/chromealex/ME.BECS.git` 4. Click **Add**. ## 3. Project Configuration There are two critical configuration steps you must perform. ### a) Allow Unsafe Code ME.BECS relies heavily on `unsafe` code for performance. 1. Go to **Edit > Project Settings > Player**. 2. In the **Other Settings** section, find **Additional Compiler Arguments**. 3. Tick the **"Allow 'unsafe' Code"** checkbox. ### b) Create `csc.rsp` File The framework uses a `csc.rsp` file to enable specific features and exceptions. 1. In your project's `Assets` directory, create a new text file named `csc.rsp`. 2. Add the following lines to the file. These are recommended for development. For release builds, you might remove the `EXCEPTIONS` and `CHECKS` defines for a slight performance boost. ``` -define:EXCEPTIONS_CONTEXT -define:EXCEPTIONS_THREAD_SAFE -define:EXCEPTIONS_COLLECTIONS -define:EXCEPTIONS_COMMAND_BUFFER -define:EXCEPTIONS_ENTITIES -define:EXCEPTIONS_QUERY_BUILDER -define:EXCEPTIONS_INTERNAL -define:EXCEPTIONS_ASPECTS -define:EXCEPTIONS -define:ENABLE_BECS_COLLECTIONS_CHECKS ``` ## 4. Creating Your First Project ME.BECS provides a template generator to scaffold your project structure. 1. In the Project window, right-click and select **Create > ME.BECS > Create Project**. 2. Enter a name for your project (e.g., `MyGame`). This action generates a `MyGame` folder with the necessary subdirectories and creates a `MyGameInitializer` prefab in your current scene. This initializer is the entry point for your ECS world. ## 5. "Hello World": Creating a System Let's create a simple system that logs a message to the console. 1. Inside the newly created `MyGame/System` folder, create a new C# script named `HelloWorldSystem.cs`. 2. Replace its content with the following code: ```csharp using ME.BECS; using UnityEngine; namespace MyGame.System { // Systems are structs that implement interfaces like IAwake, IUpdate, etc. public struct HelloWorldSystem : IAwake { // OnAwake is called once when the world is created. public void OnAwake(ref SystemContext context) { Debug.Log($"Hello from the {context.world.Name} world!"); } } } ``` > **Constraint:** All your project-specific components, systems, and aspects must be created inside your project's namespace and folder (`MyGame` in this case). ## 6. Connecting the System in the Feature Graph Systems are not automatically discovered. You must explicitly add them to a **Feature Graph**, which controls the execution flow. 1. In your project folder, find the `MyGame-FeatureGraph.asset` file and double-click it to open the Graph Editor. 2. Right-click on an empty area in the graph and select **"Create System"**. 3. In the new node, select `HelloWorldSystem` from the dropdown list. 4. Connect the graph's `Start` node to your `HelloWorldSystem` node's input port. 5. Connect the `HelloWorldSystem` node's output port to the graph's `Exit` node. 6. Click **"Save Graph"** and then **"Compile Graph"** in the editor toolbar. ## 7. Run the Scene Press **Play** in the Unity Editor. You should see the "Hello from the..." message in your console, confirming that your system was successfully executed by the framework. You have now successfully set up and run your first ME.BECS system!
```

### File: 02-Core-Architecture.md
```md
# 02: Core Architecture Understanding the core architecture of ME.BECS is crucial for leveraging its power effectively. This document covers the three pillars of its design: the World Hierarchy, the execution model, and its unique approach to memory management. ## 1. The World Hierarchy: Logic vs. Visual ME.BECS is fundamentally designed to support sophisticated networking models like client-side prediction and server rollback. This is achieved by separating the game state (**Logic**) from its on-screen representation (**Visual**). This separation is embodied through a parent-child **World Hierarchy**. ```mermaid --- config: theme: dark --- graph TD subgraph "Multiplayer Architecture" LW[Logic World] VW[Visual World] LW -- "Parent Of" --> VW LW -- "Drives State" --> VW subgraph "Responsibilities" LW_R["- Authoritative State<br>- Deterministic Simulation<br>- Network Events<br>- Physics/Collision (Trees)"] VW_R["- Renders Visuals<br>- Plays Effects/Audio<br>- Interpolates State<br>- Handles Local UI"] end LW --> LW_R VW --> VW_R end subgraph "Singleplayer (as Local Multiplayer)" SP_LW[Logic World] SP_VW[Visual World] SP_LW -- "Parent Of" --> SP_VW end style LW fill:#B22222,stroke:#fff style VW fill:#4682B4,stroke:#fff ``` ### Multiplayer Model In a standard multiplayer setup, you have two distinct worlds running simultaneously: 1. **Logic World:** * This is the **authoritative** world. It runs the core game simulation. * All logic within this world *must be deterministic*. * It processes network inputs, runs game systems (e.g., unit movement, combat), and dictates the "true" state of the game. * It has no concept of visuals, rendering, or Unity `GameObjects`. * The `LogicInitializer` on the scene manages this world. 2. **Visual World:** * This world is a **child** of the Logic World (`VisualWorld.parent = LogicWorld`). * Its sole purpose is to **observe** the state of the Logic World and present it to the player. * It runs systems responsible for instantiating and updating `GameObjects` (via the Views Module), playing visual effects, and updating UI. * It is not deterministic and can run cosmetic logic that doesn't affect gameplay. * The `VisualInitializer` on the scene manages this world. This separation is key to rollback networking: if the client mispredicts, the framework can roll back the **Logic World** to a previous state and resimulate, while the **Visual World** simply snaps to the newly corrected state. ### Singleplayer Model For singleplayer games, you can use a single world. However, **it is highly recommended to adopt the multiplayer architecture even for singleplayer games**. Treating your singleplayer game as a "local multiplayer" session (where the client is also the server) provides two major benefits: 1. **Scalability:** Your game is architecturally ready for multiplayer from day one. 2. **Clarity:** It enforces a clean separation of concerns between game logic and presentation, leading to a more robust and maintainable codebase. ## 2. Execution Order & The Update Loop System execution is not automatic. It is explicitly defined and controlled by the **Feature Graph**. ```mermaid --- config: theme: dark --- sequenceDiagram participant Unity participant BECS Initializer participant Feature Graph participant System A participant System B Unity->>BECS Initializer: Awake() BECS Initializer->>Feature Graph: ExecuteGraph() loop OnAwake Feature Graph->>System A: OnAwake(context) System A->>System B: OnAwake(context) end loop OnUpdate (every frame) Feature Feature Graph->>System A: OnUpdate(context) System A-->>Feature Graph: Returns JobHandle Feature Graph->>System B: OnUpdate(context, dependsOn: A's Handle) System B-->>Feature Graph: Returns JobHandle end ``` * **Initializers:** The `WorldInitializer` (`LogicInitializer`, `VisualInitializer`) is a `MonoBehaviour` that kicks off the creation and execution of its associated world and Feature Graph. Script Execution Order is critical to ensure the Logic World is created before the Visual World. * **Feature Graph:** This is a visual scripting tool where you define the execution order of your systems. You connect nodes to dictate the flow for each phase of the game loop (`IAwake`, `IStart`, `IUpdate`, etc.). * **Job Dependencies:** Systems can schedule jobs and return a `JobHandle`. The Feature Graph automatically passes this handle to the next system in the chain, creating a dependency. This ensures that jobs are executed in the correct order and with maximum parallelism, without needing to manually call `JobHandle.Complete()`. ## 3. Memory Management: The Zero-GC Philosophy ME.BECS is designed to avoid managed memory allocations during gameplay, thus eliminating garbage collection spikes. * **Custom Allocators:** The framework uses its own set of memory allocators (e.g., `WorldAllocator`, `TempAllocator`) built on top of Unity's `AllocatorManager`. All ECS data (entities, components) is stored in native memory managed by these allocators. * **Struct-Based:** All core data structures (`Ent`, components, aspects, systems) are `structs`. This avoids heap allocation and allows them to be used directly in Burst-compiled jobs. * **`unsafe` Code:** The framework extensively uses `unsafe` C# and pointers for direct memory manipulation, bypassing many of the overheads of the managed C# environment. * **`IDisposable`:** Worlds and other native collections must be disposed of correctly. The `WorldInitializer` handles the lifecycle of the main worlds, but any temporary worlds or collections you create must be managed manually, often with a `using` statement. * **Leak Detection:** The `LEAK_DETECTION` define can be enabled in the `csc.rsp` file during development to help identify memory leaks from undisposed native collections. This define carries a significant performance cost and should not be used in production builds.
```

### File: 03-Fundamental-Concepts.md
```md
# 03: Fundamental Concepts ME.BECS is built upon four fundamental concepts: **Entities**, **Components**, **Systems**, and **Aspects**. Mastering these building blocks is essential for working with the framework. ## 1. Entities: The "Things" An **Entity** is a simple integer ID that represents an object in your world. It is a lightweight identifier that "owns" a collection of components. ```mermaid --- config: theme: dark --- classDiagram class Ent { +int id +int version +World world } class ComponentA { <<struct>> +int data } class ComponentB { <<struct>> +sfloat speed } Ent "1" -- "0..*" ComponentA : Has Ent "1" -- "0..*" ComponentB : Has note for Ent "An Ent is just an ID with a version counter" ``` ### Key Characteristics: * **Identity:** An `Ent` struct holds an ID, a version, and a reference to the world it belongs to. * **Versioning:** The `version` is a counter that increments every time a component is added to, removed from, or modified on the entity. This is the cornerstone of the reactivity system used by Views. * **Lifecycle:** Entities are created and destroyed via the `Ent` API: ```csharp // Create a new entity in the current system's world context var newEntity = Ent.New(ref systemContext); // Destroy an entity newEntity.Destroy(); ``` * **No Data, No Logic:** An entity itself contains no data or logic. It is purely an identifier that groups components together. ## 2. Components: The Data A **Component** is a `struct` that holds data for an entity. This is where all the state of your game lives. ### Critical Constraints & Best Practices: Components in ME.BECS have strict rules to ensure performance and determinism. 1. **Must be a `struct`:** Components cannot be classes. 2. **Must be Blittable:** They must have a predictable memory layout across different architectures. This means: * **NO `bool` types.** Use `byte` (0 or 1) instead. * **NO reference types** (e.g., `string`, classes, managed arrays). * **NO `char` types.** 3. **Use Framework-Provided Types:** * For floating-point math, use `sfloat` (a deterministic fixed-point type) or `tfloat` (which can be `float` or `sfloat` depending on defines). * For collections, use the native collections provided by the framework (e.g., `ME.BECS.Collections.List<T>`). 4. **Implement `IComponent`:** All components must implement the `IComponent` marker interface. A typical component looks like this: ```csharp using ME.BECS; using ME.BECS.Math; // All components must implement IComponent public struct Health : IComponent { public sfloat value; public sfloat maxValue; } public struct IsMoving : IComponent { // Use byte for boolean flags public byte value; } ``` ## 3. Systems: The Logic A **System** is a `struct` that contains the logic to transform component data. Systems are where all the work happens in your application. ```mermaid --- config: theme: dark --- sequenceDiagram participant FeatureGraph participant HealthSystem participant Ent participant HealthComponent loop OnUpdate FeatureGraph->>HealthSystem: OnUpdate(context) HealthSystem->>Ent: Get<Health>() Ent->>HealthComponent: Access data HealthComponent-->>Ent: Return data Ent-->>HealthSystem: Return data HealthSystem->>HealthSystem: Process logic (e.g., apply regeneration) HealthSystem->>Ent: Set(newHealth) end ``` ### Key Characteristics: * **Implement Interfaces:** Systems implement interfaces that hook into the world's lifecycle, such as: * `IAwake`: Called once when the world is created. * `IStart`: Called once after `IAwake`. * `IUpdate`: Called every frame (or tick). * `IDestroy`: Called when the world is disposed. * **Stateless by Default:** Systems should ideally be stateless. Any data they need should be queried from components. Public fields on a system `struct` are treated as injection points for configuration in the Feature Graph editor. * **Job-Based:** The primary role of a system is to schedule jobs that run in parallel, operating on component data. ## 4. Aspects: The High-Performance Accessor An **Aspect** is a specialized `struct` that provides high-performance, direct access to a group of components for a single entity. It is the preferred way to work with component data inside jobs. ### Why Use Aspects? Querying for each component individually (`ent.Get<A>()`, `ent.Get<B>()`) can be slow due to the lookups involved. An Aspect consolidates these lookups into a single operation, giving you direct memory references to the component data. ```csharp using ME.BECS; // Define the components public struct Position : IComponent { public float3 value; } public struct Velocity : IComponent { public float3 value; } // Define the Aspect to group them public struct MovementAspect : IAspect { // This property is required by the IAspect interface public Ent ent { get; set; } // These fields provide direct, cached access to the component data. // Use RefRW for read/write access, or RefRO for read-only. private RefRW<Position> position; private RefRW<Velocity> velocity; // Public properties provide a clean API public ref float3 Position => ref this.position.Get(this.ent.id); public ref float3 Velocity => ref this.velocity.Get(this.ent.id); // You can also add methods for complex logic public void ApplyMovement(float deltaTime) { this.Position += this.Velocity * deltaTime; } } // In a system's job: var aspect = ent.GetAspect<MovementAspect>(); aspect.ApplyMovement(deltaTime); ``` By using `MovementAspect`, you perform one lookup to get pointers to both `Position` and `Velocity`, which is significantly faster than two separate lookups, especially when processing thousands of entities in a tight loop.
```

### File: 04-Data-Logic-Workflows.md
```md
# 04: Data & Logic Workflows This document covers the primary workflows for implementing game logic and managing data in ME.BECS. It focuses on how to query for entities, process them in parallel jobs, define their archetypes using configs, and orchestrate everything using the Feature Graph. ## 1. Queries & Jobs: Processing Data in Parallel The core of most systems is to find a set of entities that have specific components and then process them. This is done through **Queries** and **Jobs**. The recommended and most performant approach is to use **Aspects** within your jobs. ```mermaid --- config: theme: dark --- graph TD A[System's OnUpdate] --> B[Define Query]; B --> C[Create Job Struct]; C --> D[Schedule Job with Query]; D --> E[Return JobHandle]; subgraph Query Definition direction LR B1[Specify Aspect<T>] B2[Specify Components<A, B>] B3[Add Filters .With<C>.Without<D>] end subgraph Job Logic C1[Implement IJobForAspects<T>] C2[Execute(in Ent, ref T aspect)] end B --> B1 & B2 & B3 C --> C1 & C2 style E fill:#2E8B57,stroke:#fff ``` ### The Workflow 1. **Define a Job:** Create a `struct` that implements one of the job interfaces, such as `IJobForAspects<T>`. The `Execute` method of this struct contains the logic that will run for each entity. 2. **Define a Query:** In your system's `OnUpdate` method, use `API.Query()` to define which entities the job should run on. You specify the Aspect and any additional component filters. 3. **Schedule the Job:** Call `.Schedule()` on the query, passing in an instance of your job struct. This returns a `JobHandle`. 4. **Set Dependency:** Return the `JobHandle` from your system's `OnUpdate` method by passing it to `context.SetDependency()`. The framework will manage the job's completion. ### Example: ```csharp using ME.BECS; using ME.BECS.Jobs; // Aspect defined in 03-Fundamental-Concepts.md // public struct MovementAspect : IAspect { ... } public struct MovementSystem : IUpdate { // 1. Define the Job [BurstCompile] private struct MoveJob : IJobForAspects<MovementAspect> { // Inject the frame's delta time [InjectDeltaTime] public float deltaTime; public void Execute(in Ent ent, ref MovementAspect aspect) { aspect.Position += aspect.Velocity * this.deltaTime; } } public void OnUpdate(ref SystemContext context) { // 2. Define the Query for all entities with MovementAspect var query = API.Query(context); // 3. Schedule the Job var jobHandle = query.Schedule<MoveJob, MovementAspect>(new MoveJob()); // 4. Set the dependency for the framework to manage context.SetDependency(jobHandle); } } ``` > **Best Practice:** Always return the `JobHandle` via `context.SetDependency()`. Avoid calling `.Complete()` inside a system as it creates a sync point and stalls the main thread, defeating the purpose of multithreading. ## 2. Entity Configs: The "Prefab" System **Entity Configs** are `ScriptableObject` assets that define an entity's archetype. They are the ME.BECS equivalent of Unity's prefabs, allowing you to define a template of components and their initial data. ```mermaid --- config: theme: dark --- graph TD A[Entity Config Asset] --> B{Component Types}; B -- Static --> C[Static Components]; B -- Dynamic --> D[Dynamic Components]; subgraph "Static Components" C1["- Data that rarely changes<br>- e.g., Max Health, Model Reference<br>- Shared across all instances<br>- Accessed via <b>ReadStatic<T>()</b>"] end subgraph "Dynamic Components" D1["- Initial state for an entity<br>- e.g., Current Health, Position<br>- Copied to the entity on creation<br>- Accessed via <b>Get<T>() / Read<T>()</b>"] end C --> C1 D --> D1 ``` ### Key Features: * **Static Components:** Data that is shared by all entities created from this config. It's stored only once on the config itself, saving significant memory. Use this for data that doesn't change at runtime (e.g., unit type, max speed, a reference to a view prefab). Accessed via `ent.ReadStatic<MyComponent>()`. * **Dynamic Components:** Data that is copied to the entity when it is instantiated. This is the initial state of the entity (e.g., current health set to max health, initial position). * **Inheritance:** Configs can inherit from other configs, allowing you to create layered definitions (e.g., `BaseUnit` -> `InfantryUnit` -> `Rifleman`). * **Data-Driven Design:** Because configs are assets, they can be easily modified by designers. The **CSV Configs Importer** tool even allows you to import data directly from Google Sheets into your configs, enabling a powerful data-driven workflow. ## 3. The Feature Graph: Orchestrating Systems The **Feature Graph** is a visual editor that defines the execution order and dependencies of all your systems. It is the central hub for controlling your application's logic flow. * **Visual Workflow:** Instead of managing execution order via attributes or complex code, you visually connect nodes in a graph. * **Execution Phases:** The graph has entry points for each lifecycle event (`Start`, `Update`, etc.), allowing you to define which systems run and in what order for each phase. * **Dependencies:** The graph automatically handles `JobHandle` dependencies. If System A's output is connected to System B's input, the framework ensures System A's jobs are completed before System B's jobs begin, or chains them appropriately. * **Features:** You can group systems into "Features" (other graphs), which can be enabled or disabled. This allows you to create modular blocks of functionality. By combining Queries, Jobs, Configs, and the Feature Graph, you get a powerful and highly performant workflow for building complex game logic in a data-oriented and scalable way.
```

### File: 05-Rendering-and-Views.md
```md
# 05: Rendering & The Views Module ME.BECS maintains a strict separation between simulation logic and visual presentation. The **Views Module** is the official bridge that connects the data-oriented ECS world to Unity's `GameObject`-based rendering engine. ## The Core Concept: Reacting to State Changes Views do not have direct access to modify the logic world. Instead, they **observe** the state of an entity and **react** when its data changes. This is achieved through the entity versioning system. ```mermaid --- config: theme: dark --- sequenceDiagram participant LogicWorld participant VisualWorld participant EntityView participant ViewModule LogicWorld->>LogicWorld: System modifies a component on an Ent note right of LogicWorld: Ent's Version is incremented VisualWorld->>EntityView: OnUpdate() EntityView->>EntityView: Compare last known version with Ent's current version opt Version has changed EntityView->>EntityView: Call ApplyState() note right of EntityView: Update last known version EntityView->>ViewModule: Delegate ApplyState() to all attached modules ViewModule->>ViewModule: Update Unity components (Transform, Material, etc.) end ``` The `ApplyState()` method is the heart of the Views system. It is only called when an entity's data has been modified, making it a highly efficient way to keep visuals in sync with the game state. ## 1. `EntityView`: The `GameObject` Representative An `EntityView` is a `MonoBehaviour` that you place on a prefab. It represents a single ECS entity in the `GameObject` world. * **Link to ECS:** It holds a reference to the `Ent` it represents. * **View Modules Container:** Its primary job is to act as a container for one or more `ViewModule` components. It receives the `ApplyState` call and delegates it to its modules. * **Prefab Asset:** You create a prefab with an `EntityView` component and any other necessary `MonoBehaviour`s (like `ViewModule`s). This prefab is then referenced in an `EntityConfig` to be spawned at runtime. ## 2. `ViewModule`: Compositional & Reusable Logic A `ViewModule` is a `MonoBehaviour` that contains a specific piece of visual logic. Instead of creating a monolithic `PlayerView` `MonoBehaviour` that handles movement, health bars, and selection effects, you create small, reusable modules for each. * **`HealthBarViewModule`:** Observes the `Health` component and updates a UI slider. * **`TransformViewModule`:** Observes `Position` and `Rotation` components and updates the `GameObject`'s transform. * **`SelectionEffectViewModule`:** Observes an `IsSelected` component and enables/disables a projector or outline effect. This compositional approach is more flexible and maintainable than inheritance. ### Example `ViewModule`: ```csharp using ME.BECS; using ME.BECS.Views; using UnityEngine; // A module to handle updating the GameObject's position public class TransformViewModule : ViewModule { // This method is called by the EntityView when the entity's version changes public override void ApplyState(in Ent ent) { // Check if the entity has the required components if (ent.Has<Position>() == true && ent.Has<Rotation>() == true) { // Read the data from the ECS components var position = ent.Read<Position>().value; var rotation = ent.Read<Rotation>().value; // Apply the state to the Unity Transform this.transform.position = position; this.transform.rotation = rotation; } } } ``` ## 3. Culling: Optimizing View Updates The Views system includes a powerful culling mechanism to save performance on objects that are not visible to the camera. * **`CullingType`:** On the `EntityView` component, you can set a `CullingType`. * **Behavior:** When an entity is culled (e.g., outside the camera's frustum), the framework will stop calling `OnUpdate()` and `ApplyState()` on its `EntityView` and all associated `ViewModule`s. * **Performance Gain:** This is a significant optimization, as it prevents expensive visual update logic from running on thousands of off-screen entities. * **Camera Injection:** To make culling work, the `ViewsModule` on your `WorldInitializer` needs a reference to the main camera, which is typically injected by adding a `CameraAspect` to the module. By using this architecture, you maintain a clean separation between your deterministic game logic and your presentation layer, while still having a powerful and efficient pipeline for rendering your ECS world.
```

### File: 06-Networking.md
```md
# 06: The Networking Model ME.BECS is architected around a high-performance, deterministic networking model designed for real-time multiplayer games. It uses a client-side prediction and server rollback architecture to provide a responsive player experience even with network latency. ## Architecture: Prediction, Rollback, and Determinism The entire model is built on three pillars: the client predicts, the server validates, and deterministic logic ensures both can arrive at the same result. ```mermaid --- config: theme: dark --- graph LR subgraph Client A[Input Hardware] --> B[Input System] B --> C{Diff vs Last Frame?} C -- Yes --> D[Send Network Event to Server] D --> E[Apply Input Locally (Prediction)] E --> F[Render Predicted Frame] end subgraph Server D -.-> G[Receive Input Packet] G --> H[Run Logic Tick] H --> I[Authoritative State] end subgraph Client Correction I -.-> J[Receive Server State] J --> K{State Mismatch?} K -- Yes --> L[Rollback & Replay Inputs] L --> F K -- No --> F end style E fill:#4682B4,stroke:#fff style L fill:#B22222,stroke:#fff ``` ### 1. Client-Side Prediction When a player performs an action (e.g., presses a move key), the input is not held until the server responds. Instead: 1. The input is immediately sent to the server as a **Network Event** or **Command**. 2. Simultaneously, the client's **Logic World** *predicts* the outcome of that input and simulates the next few ticks locally. 3. The **Visual World** renders this predicted state. To the player, the action appears to happen instantly. ### 2. Server Authority The server is the ultimate source of truth. 1. It receives a stream of input events from all clients. 2. It processes these inputs in its own deterministic simulation (the authoritative Logic World). 3. Periodically, it sends snapshots of the authoritative game state back to the clients. ### 3. Rollback and Replay When the client receives a state snapshot from the server, it compares it to its own predicted state for that same tick. * **If they match:** The prediction was correct, and everything continues smoothly. * **If they mismatch:** A "misprediction" occurred. This could be due to another player's action that the client hadn't received yet, or network latency. The framework then automatically performs a **rollback**: 1. The client's Logic World is reset to the last known authoritative state from the server. 2. It then **replays** all the local player's inputs from that point forward to the present tick. 3. The Visual World snaps to this newly corrected state. Because this process is extremely fast, the correction is often imperceptible to the player, appearing as a minor visual "pop" or adjustment. ## Determinism: The Cornerstone of Networking This entire model falls apart if the client and server simulations don't produce the exact same results from the same inputs. **Deterministic logic is a strict requirement.** ### Best Practices for Determinism: 1. **No `UnityEngine.Random`:** Use the framework's provided random number generator, which can be seeded to produce a repeatable sequence. 2. **No `Time.deltaTime`:** The simulation is advanced in fixed-step ticks. Use the `deltaTime` provided by the system context or injected into jobs. 3. **No `UnityEngine.Physics`:** Unity's physics engine is not deterministic. For collision and spatial queries, use the **Trees (QuadTree/Octree) Addon** provided with ME.BECS. 4. **Use Deterministic Math:** Use the framework's `sfloat` fixed-point math types and functions from the `ME.BECS.Math` namespace for any gameplay calculations. 5. **Floating Point Order of Operations:** Be aware that floating-point math is not perfectly associative (e.g., `(a + b) + c` is not always identical to `a + (b + c)`). Process inputs and calculations in a consistent order. ## Network Events & Commands Inputs are sent as simple `structs` that implement `INetworkEvent`. ```csharp using ME.BECS.Network; public struct MoveCommand : INetworkEvent { public int targetEntityId; public float2 targetPosition; } // On the client: var cmd = new MoveCommand { ... }; // Get the network module and send the event networkModule.AddEvent(cmd); // On the server (or in a logic system): // The event will be available in the context to be processed. ``` By adhering to these principles, you can build complex, responsive, and robust multiplayer experiences with ME.BECS.
```

### File: 07-Advanced-Topics.md
```md
# 07: Advanced Topics & Addons This document covers several powerful, specialized features and addons within ME.BECS that are crucial for building a complete game. ## 1. Trees: Deterministic Spatial Partitioning Because Unity's `Physics` module is non-deterministic, ME.BECS provides its own solution for spatial queries and collision detection: the **Trees Addon**. This addon uses data structures like QuadTrees (for 2D/top-down 3D) or Octrees (for full 3D) to efficiently and deterministically find entities within a given area. ```mermaid --- config: theme: dark --- graph TD A[System Update] --> B{Need continuous check?}; B -- Yes (e.g., Attack Aura) --> C[Entity with Seeker Aspect]; C --> D[Query QuadTree every Tick]; D --> E[Store Results in a Component]; B -- No (e.g., 'Chop Tree' command) --> F[Direct API Call: GetNearest]; F --> G[Optionally Apply Custom SubFilter]; G --> H[Return Result Immediately]; style C fill:#4682B4 style F fill:#2E8B57 ``` ### Workflows for Using Trees: 1. **Continuous Queries (Seekers):** * **Use Case:** An entity needs to constantly be aware of its surroundings, like a turret looking for targets or a unit with a damage aura. * **Implementation:** Add a `QuadTreeQuery` aspect (a "Seeker") to your entity. The framework will automatically query the tree every tick and store the results (e.g., a list of nearby entities) in a component on your seeker entity. Your systems can then simply read the results from that component. 2. **One-Off Queries (Direct API):** * **Use Case:** You need to find something in response to a single event, like finding the nearest resource when a worker is given a "gather" command. * **Implementation:** Use the direct API provided by the Tree system (e.g., `QuadTree.GetNearest()`). This is more efficient than creating a persistent Seeker entity for a one-time check. * **Sub-Filtering:** You can provide a custom `ISubFilter` struct to the query to further refine the results (e.g., "Find the nearest enemy unit with less than 50% health"). ## 2. Players & Teams: Ownership and Metadata In many games, especially multiplayer ones, you need to track which player owns which units and how they relate to each other (friend or foe). * **Player Entity:** A `Player` is a distinct entity that represents the human connection or an AI player. It is separate from the units that player controls. A common strategy is to derive the `PlayerID` from the `ClientID` (e.g., `PlayerID = ClientID + 1`), reserving Player 0 for neutral or environment-owned entities. * **Team Entity:** A `Team` is also an entity. Players are assigned to a team. * **Ownership:** Game units (e.g., soldiers, workers) have a component that stores the `Ent` of the player who owns them. * **Updating Masks:** When team assignments change, you must call `UpdateTeams` to refresh the internal collision and interaction masks, which are used by systems like the Trees addon to correctly identify friends, foes, and neutral parties. ## 3. Global Events: Communicating with UI Directly querying ECS data from a `MonoBehaviour` every frame is inefficient and breaks the separation of concerns. The recommended way for the ECS world to communicate with the UI (or other `GameObject`-based systems) is via a **Global Event Bus**. ```mermaid --- config: theme: dark --- sequenceDiagram participant LogicSystem participant GlobalEventBus participant UI_Widget loop Game Tick LogicSystem->>LogicSystem: Unit takes damage LogicSystem->>GlobalEventBus: RaiseEvent(HealthChangedEvent) Note right of GlobalEventBus: Event is queued/debounced end loop Unity's LateUpdate GlobalEventBus->>UI_Widget: Trigger OnEvent (once per frame) UI_Widget->>UI_Widget: Update Health Bar display end ``` * **Workflow:** 1. A logic system detects a state change (e.g., health changes, a unit dies). 2. It raises a global event, which is a simple `struct`. 3. The `GlobalEventBus` accumulates all events fired within a single tick. 4. At the end of the frame, it de-bounces them and triggers callbacks on any UI widgets or `MonoBehaviour`s that are listening for that event type. * **Benefit:** This ensures the UI only redraws once per frame with the latest data, even if the underlying data changed multiple times during the logic tick. It's a highly decoupled and performant way to drive UI from ECS state. ## 4. CSV Configs Importer: Data-Driven Design The **CSV Configs Importer** is a powerful editor tool that allows you to define your `EntityConfig` data in a Google Sheet and import it directly into Unity. * **Workflow:** 1. Create a Google Sheet with columns corresponding to your component fields. 2. Publish the sheet to the web as a CSV file. 3. In Unity, create an `Entity Config CSV Importer` asset. 4. Paste the CSV URL into the importer asset and click `LOAD`. * **Benefit:** This enables a rapid, data-driven iteration loop. Designers can balance units, define items, and tweak stats in a spreadsheet without needing to open the Unity editor or have a programmer make changes. The tool also supports cross-linking between configs within the sheet.
```

### File: Cookbook-Best-Practices.md
```md
# ME.BECS Cookbook & Best Practices This document provides a quick-reference guide to the most important rules, constraints, and recommended patterns for working with ME.BECS. Following these guidelines will help you write performant, deterministic, and maintainable code. ## Architecture & Project Setup * **Do** use the Logic/Visual World hierarchy, even for singleplayer games. It enforces a clean separation of concerns and makes your project future-proof for multiplayer. * **Do** pay attention to Script Execution Order. Your `LogicInitializer` must always run before your `VisualInitializer`. * **Do** place all your project-specific code (components, systems, aspects) inside the dedicated project folder and namespace generated by the "Create Project" tool. * **Do** use the `csc.rsp` file to manage defines. Enable `ENABLE_BECS_COLLECTIONS_CHECKS` and `EXCEPTIONS` during development for better error checking. --- ## Components: The Data * **Don't** use `bool` in components. It is not blittable. Use `byte` (0 or 1) instead. * **Don't** use managed types (classes, `string`, managed arrays) in components. All component data must be blittable. * **Do** use the framework's deterministic math types (`sfloat`, `float2`, `quaternion`) for any data involved in the simulation. * **Do** use `IComponentShared` for data that is identical across many entities to save memory. * **Do** use `IConfigComponentStatic` for data in `EntityConfig`s that never changes at runtime (e.g., max health, move speed). Access it via `ent.ReadStatic<T>()`. --- ## Systems & Jobs: The Logic * **Do** use Aspects (`IAspect`) and `IJobForAspects` for the most performant data access in jobs. * **Don't** call `.Complete()` on a `JobHandle` inside a system's `OnUpdate`. * **Do** return the final `JobHandle` from your system by calling `context.SetDependency(jobHandle)`. The framework's scheduler will manage dependencies for you. * **Do** use the Feature Graph to define the execution order of your systems. It's the central place to manage logic flow. * **Don't** put complex, stateful logic inside systems. Systems should be lightweight `structs` that primarily schedule jobs. --- ## Determinism & Networking * **Don't** use `UnityEngine.Random`. Use the world's random generator: `context.world.GetRandom()`. * **Don't** use `Time.deltaTime`. Use the `deltaTime` provided by the `SystemContext` or injected into a job. * **Don't** use `UnityEngine.Physics` for gameplay logic. Use the **Trees Addon** (QuadTree/Octree) for deterministic spatial queries. * **Do** send player input as `INetworkEvent` structs to the server/logic world. Don't apply inputs directly on the client. * **Do** ensure all logic in your **Logic World** is 100% deterministic. Any non-deterministic code (e.g., related to rendering, audio) must only exist in the **Visual World**. --- ## Views & Rendering * **Don't** let Views modify the logic world. Views should only **read** from the ECS state and **react** to changes. * **Do** use the `ApplyState()` method in your `ViewModule`s. It's the most efficient way to update visuals, as it only runs when the entity's data has actually changed. * **Do** favor composition over inheritance. Build complex views by adding multiple, small `ViewModule`s to an `EntityView` prefab. * **Do** use the `CullingType` property on `EntityView` to disable updates for off-screen objects and save performance. --- ## General Performance & Memory * **Do** use `RefRO<T>` (Read-Only) instead of `RefRW<T>` in Aspects whenever you don't need to write to a component. This can help the job scheduler find more opportunities for parallelism. * **Do** use `ent.Read<T>()` instead of `ent.Get<T>()` when you only need to read data. `Read` is faster as it doesn't involve a potential write-back or version change. * **Do** use the `LEAK_DETECTION` define during development to find memory leaks from native collections that you might have created but not disposed. * **Don't** perform expensive queries or logic every frame if it can be avoided. For one-off spatial searches, use the Tree's direct API (`GetNearest`) instead of creating a persistent "Seeker" entity.
```
