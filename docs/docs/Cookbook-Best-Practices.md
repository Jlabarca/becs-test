# ME.BECS Cookbook & Best Practices

This document provides a quick-reference guide to the most important rules, constraints, and recommended patterns for working with ME.BECS. Following these guidelines will help you write performant, deterministic, and maintainable code.

## Architecture & Project Setup

*   **Do** use the Logic/Visual World hierarchy, even for singleplayer games. It enforces a clean separation of concerns and makes your project future-proof for multiplayer.
*   **Do** pay attention to Script Execution Order. Your `LogicInitializer` must always run before your `VisualInitializer`.
*   **Do** place all your project-specific code (components, systems, aspects) inside the dedicated project folder and namespace generated by the "Create Project" tool.
*   **Do** use the `csc.rsp` file to manage defines. Enable `ENABLE_BECS_COLLECTIONS_CHECKS` and `EXCEPTIONS` during development for better error checking.

---

## Components: The Data

*   **Don't** use `bool` in components. It is not blittable. Use `byte` (0 or 1) instead.
*   **Don't** use managed types (classes, `string`, managed arrays) in components. All component data must be blittable.
*   **Do** use the framework's deterministic math types (`sfloat`, `float2`, `quaternion`) for any data involved in the simulation.
*   **Do** use `IComponentShared` for data that is identical across many entities to save memory.
*   **Do** use `IConfigComponentStatic` for data in `EntityConfig`s that never changes at runtime (e.g., max health, move speed). Access it via `ent.ReadStatic<T>()`.

---

## Systems & Jobs: The Logic

*   **Do** use Aspects (`IAspect`) and `IJobForAspects` for the most performant data access in jobs.
*   **Don't** call `.Complete()` on a `JobHandle` inside a system's `OnUpdate`.
*   **Do** return the final `JobHandle` from your system by calling `context.SetDependency(jobHandle)`. The framework's scheduler will manage dependencies for you.
*   **Do** use the Feature Graph to define the execution order of your systems. It's the central place to manage logic flow.
*   **Don't** put complex, stateful logic inside systems. Systems should be lightweight `structs` that primarily schedule jobs.

---

## Determinism & Networking

*   **Don't** use `UnityEngine.Random`. Use the world's random generator: `context.world.GetRandom()`.
*   **Don't** use `Time.deltaTime`. Use the `deltaTime` provided by the `SystemContext` or injected into a job.
*   **Don't** use `UnityEngine.Physics` for gameplay logic. Use the **Trees Addon** (QuadTree/Octree) for deterministic spatial queries.
*   **Do** send player input as `INetworkEvent` structs to the server/logic world. Don't apply inputs directly on the client.
*   **Do** ensure all logic in your **Logic World** is 100% deterministic. Any non-deterministic code (e.g., related to rendering, audio) must only exist in the **Visual World**.

---

## Views & Rendering

*   **Don't** let Views modify the logic world. Views should only **read** from the ECS state and **react** to changes.
*   **Do** use the `ApplyState()` method in your `ViewModule`s. It's the most efficient way to update visuals, as it only runs when the entity's data has actually changed.
*   **Do** favor composition over inheritance. Build complex views by adding multiple, small `ViewModule`s to an `EntityView` prefab.
*   **Do** use the `CullingType` property on `EntityView` to disable updates for off-screen objects and save performance.

---

## General Performance & Memory

*   **Do** use `RefRO<T>` (Read-Only) instead of `RefRW<T>` in Aspects whenever you don't need to write to a component. This can help the job scheduler find more opportunities for parallelism.
*   **Do** use `ent.Read<T>()` instead of `ent.Get<T>()` when you only need to read data. `Read` is faster as it doesn't involve a potential write-back or version change.
*   **Do** use the `LEAK_DETECTION` define during development to find memory leaks from native collections that you might have created but not disposed.
*   **Don't** perform expensive queries or logic every frame if it can be avoided. For one-off spatial searches, use the Tree's direct API (`GetNearest`) instead of creating a persistent "Seeker" entity.
